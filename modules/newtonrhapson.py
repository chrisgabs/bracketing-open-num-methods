# -*- coding: utf-8 -*-
"""NewtonRhapson.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rPTus5CwYJyB05W-gZSfCHaxvJqSjNhb
"""

from sympy.abc import x
from sympy.parsing.sympy_parser import parse_expr, standard_transformations, implicit_multiplication_application, \
    convert_xor
import pandas as pd
from IPython.display import display, HTML
import numpy as np


def get_f_x(curr_x, equation, equation_prime):
    new_f_x = equation.subs(x, curr_x)
    f_x_prime = equation_prime.subs(x, curr_x)
    val = curr_x - (new_f_x / f_x_prime)
    return val


def get_error(curr_f_x, prev_f_x):
    return abs(((curr_f_x - prev_f_x) / curr_f_x)) * 100


def newton_rhapson(eq, currx, crit):
    transformations = (standard_transformations + (implicit_multiplication_application,) + (convert_xor,))
    # Insert value for the equation
    equation = parse_expr(eq, transformations=transformations)

    # Insert initial curr_x value
    curr_x = currx

    # Insert value for stopping criterion
    stopping_criterion = crit

    # Get equation derivative
    equation_prime = equation.diff(x)
    # Instantiate dataframe
    df = pd.DataFrame(columns=['iteration', 'curr_x', 'f_x', 'error'])
    # Iteration index
    iteration = int(0)
    error = 100
    f_x = 0

    arr = [iteration, curr_x, f_x, error]
    df = df.append(dict(zip(df.columns, arr)), ignore_index=True)
    iteration += 1

    while error >= float(stopping_criterion):
        prev_f_x = curr_x
        curr_x = get_f_x(prev_f_x, equation, equation_prime)
        error = get_error(curr_x, prev_f_x)
        arr = [iteration, prev_f_x, curr_x, error]
        df = df.append(dict(zip(df.columns, arr)), ignore_index=True)
        iteration += 1

    return (df)
